"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-any
const cross_fetch_1 = require("cross-fetch");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const Option_1 = require("fp-ts/lib/Option");
const pipeable_1 = require("fp-ts/lib/pipeable");
const TaskEither_1 = require("fp-ts/lib/TaskEither");
const errors_1 = require("./errors");
exports.defaultExtractor = (response) => {
    var _a;
    const contentType = response.headers.get('content-type');
    return ((_a = contentType) === null || _a === void 0 ? void 0 : _a.includes('application/json')) ? response.json() : response.text();
};
exports.jsonExtractor = (response) => response.json();
exports.textExtractor = (response) => response.text();
/**
 * Fetcher – a thin type-safe wrapper around @global fetch API
 *
 * @export
 * @class Fetcher
 * @template TResult Sum type of a @see Result records
 * @template To Target type the fetched result will be transformed into
 *
 * @example
 *
 */
class Fetcher {
    /**
     * Create a new instance of a Fetcher class
     * @param {RequestInfo} input Fetch input – either a string or a @see Request instance
     * @param {RequestInit} [init] Fetch initialization parameters
     * @param {Fetch} [fetch=crossFetch] (optional) Fetch function override – useful for testing
     * @memberof Fetcher
     */
    constructor(input, init, fetch = cross_fetch_1.fetch) {
        this.input = input;
        this.init = init;
        this.fetch = fetch;
        this.handlers = new Map();
        this.restHandler = void 0;
    }
    /**
     * Transform `Fetcher<T, A>` into `Fetcher<T, B>`.
     * A functor method.
     *
     * @template B Type of the transformation result
     * @param {(a: To) => B} f Transformation function. Will be applied to all registered handlers.
     * @returns {Fetcher<TResult, B>} Transformed result
     * @memberof Fetcher
     */
    map(f) {
        for (const [code, [handler, codec, extractor]] of this.handlers) {
            this.handlers.set(code, function_1.unsafeCoerce([function_1.flow(handler, f), codec, extractor]));
        }
        return function_1.unsafeCoerce(this);
    }
    /**
     * Register a handler for given code
     *
     * @template Code Type-level HTTP code literal – optional, inferrable
     * @param {Code} code HTTP code. Must be present in `TResult` sum type parameter of @see Fetcher
     * @param {(data: Data<TResult, Code>) => To} handler Handler for the given code
     * @param {io.Type<Data<TResult, Code>>} [codec] Optional codec for `To` type, used for validation
     * @returns {Fetcher<Handled<TResult, Code>, To>} A fetcher will `code` being handled
     * (so it's not possible to register another handler for it)
     * @memberof Fetcher
     */
    handle(code, handler, codec, extractor = exports.defaultExtractor) {
        this.handlers.set(code, [handler, codec, extractor]);
        return function_1.unsafeCoerce(this);
    }
    /**
     * Handle all not handled explicitly response statuses using a provided fallback thunk
     *
     * @param {() => To} restHandler Thunk of a `To` type. Will be called if no suitable handles are found
     * for the response status code
     * @returns {Fetcher<Handled<TResult, never>, To>} Fetcher with ALL status codes being handled.
     * Note that you won't be able to add any additional handlers to the chain after a call to this method!
     * @memberof Fetcher
     */
    discardRest(restHandler) {
        this.restHandler = restHandler;
        return function_1.unsafeCoerce(this);
    }
    /**
     * Convert a `Fetcher<T, A>` into a `TaskEither<Error, [A, Option<Errors>]>`.
     *
     * @returns {TaskEither<Error, [To, Option<io.Errors>]>} A `TaskEither` representing this `Fetcher`
     * @memberof Fetcher
     */
    toTaskEither() {
        return TaskEither_1.tryCatch(() => this.run(), (reason) => reason instanceof Error ? reason : new Error(`Something went wrong, details: ${reason}`));
    }
    /**
     * Actually performs @external fetch request and executes and suitable handlers.
     *
     * @returns {Promise<[To, Option<io.Errors>]>} A promise of a pair of result and possible validation errors
     * @memberof Fetcher
     */
    async run() {
        try {
            const response = await this.fetch(this.input, this.init);
            const status = response.status;
            const triplet = this.handlers.get(status);
            if (triplet != null) {
                const [handler, codec, extractor] = triplet;
                try {
                    const body = await extractor(response);
                    try {
                        if (codec) {
                            return pipeable_1.pipe(codec.decode(body), Either_1.fold((errors) => [handler(body), Option_1.some(errors)], (res) => [handler(res), Option_1.none]));
                        }
                        return [handler(body), Option_1.none];
                    }
                    catch (error) {
                        return Promise.reject(new Error(`Handler side error, details: ${error}`));
                    }
                }
                catch (jsonError) {
                    return Promise.reject(new errors_1.JsonDeserializationError(`Could not deserialize response JSON, details: ${jsonError}`));
                }
            }
            if (this.restHandler != null) {
                return [this.restHandler(), Option_1.none];
            }
            return Promise.reject(new errors_1.HandlerNotSetError(`Neither handler for ${status} nor rest handler are set - consider adding \`.handle(${status}, ...)\` or \`.discardRest(() => ...)\` calls to the chain`));
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
}
exports.Fetcher = Fetcher;
