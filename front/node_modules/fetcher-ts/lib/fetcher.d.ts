import { Option } from 'fp-ts/lib/Option';
import { TaskEither } from 'fp-ts/lib/TaskEither';
import * as io from 'io-ts';
/**
 * Result of a fetch request – basically, a pair of code and payload
 */
export declare type Result<Code extends number, A> = {
    code: Code;
    payload: A;
};
export declare type Extractor<TResult, Code extends number> = (response: Response) => Promise<Data<TResult, Code>>;
declare type Handled<T, Code extends number> = T extends Result<infer C, infer D> ? C extends Code ? never : Result<C, D> : never;
declare type Data<T, Code extends number> = T extends Result<infer C, infer D> ? C extends Code ? D : never : never;
/**
 * Fetch type – just for convenience
 */
export declare type Fetch = typeof fetch;
export declare const defaultExtractor: (response: Response) => Promise<any>;
export declare const jsonExtractor: (response: Response) => Promise<any>;
export declare const textExtractor: (response: Response) => Promise<string>;
/**
 * Fetcher – a thin type-safe wrapper around @global fetch API
 *
 * @export
 * @class Fetcher
 * @template TResult Sum type of a @see Result records
 * @template To Target type the fetched result will be transformed into
 *
 * @example
 *
 */
export declare class Fetcher<TResult extends Result<any, any>, To> {
    private readonly input;
    private readonly init?;
    private readonly fetch;
    private readonly handlers;
    private restHandler?;
    /**
     * Create a new instance of a Fetcher class
     * @param {RequestInfo} input Fetch input – either a string or a @see Request instance
     * @param {RequestInit} [init] Fetch initialization parameters
     * @param {Fetch} [fetch=crossFetch] (optional) Fetch function override – useful for testing
     * @memberof Fetcher
     */
    constructor(input: RequestInfo, init?: RequestInit | undefined, fetch?: Fetch);
    /**
     * Transform `Fetcher<T, A>` into `Fetcher<T, B>`.
     * A functor method.
     *
     * @template B Type of the transformation result
     * @param {(a: To) => B} f Transformation function. Will be applied to all registered handlers.
     * @returns {Fetcher<TResult, B>} Transformed result
     * @memberof Fetcher
     */
    map<B>(f: (a: To) => B): Fetcher<TResult, B>;
    /**
     * Register a handler for given code
     *
     * @template Code Type-level HTTP code literal – optional, inferrable
     * @param {Code} code HTTP code. Must be present in `TResult` sum type parameter of @see Fetcher
     * @param {(data: Data<TResult, Code>) => To} handler Handler for the given code
     * @param {io.Type<Data<TResult, Code>>} [codec] Optional codec for `To` type, used for validation
     * @returns {Fetcher<Handled<TResult, Code>, To>} A fetcher will `code` being handled
     * (so it's not possible to register another handler for it)
     * @memberof Fetcher
     */
    handle<Code extends TResult['code']>(code: Code, handler: (data: Data<TResult, Code>) => To, codec?: io.Type<Data<TResult, Code>>, extractor?: Extractor<TResult, Code>): Fetcher<Handled<TResult, Code>, To>;
    /**
     * Handle all not handled explicitly response statuses using a provided fallback thunk
     *
     * @param {() => To} restHandler Thunk of a `To` type. Will be called if no suitable handles are found
     * for the response status code
     * @returns {Fetcher<Handled<TResult, never>, To>} Fetcher with ALL status codes being handled.
     * Note that you won't be able to add any additional handlers to the chain after a call to this method!
     * @memberof Fetcher
     */
    discardRest(restHandler: () => To): Fetcher<Handled<TResult, never>, To>;
    /**
     * Convert a `Fetcher<T, A>` into a `TaskEither<Error, [A, Option<Errors>]>`.
     *
     * @returns {TaskEither<Error, [To, Option<io.Errors>]>} A `TaskEither` representing this `Fetcher`
     * @memberof Fetcher
     */
    toTaskEither(): TaskEither<Error, [To, Option<io.Errors>]>;
    /**
     * Actually performs @external fetch request and executes and suitable handlers.
     *
     * @returns {Promise<[To, Option<io.Errors>]>} A promise of a pair of result and possible validation errors
     * @memberof Fetcher
     */
    run(): Promise<[To, Option<io.Errors>]>;
}
export {};
